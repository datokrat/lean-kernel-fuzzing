CoeHTC
rec
semiOutParam
u
α
MonadReaderOf
mk
v
a
_@
Init
Prelude
_hyg
read
m
ρ
read
self
Nat
zero
succ
n
LE
mk
le
le
le
refl
step
instLENat
OfNat
mk
ofNat
x
_@
Init
Prelude
_hyg
ofNat
instOfNatNat
rec
casesOn
t
succ
zero
motive
n_ih
rec
casesOn
step
refl
a_ih
_@
Init
Prelude
_hyg
Eq
refl
u_1
HEq
refl
β
rec
ndrec
u2
u1
h
b
rfl
symm
_@
Init
Prelude
_hyg
letFun
f
cast
rec
eq_of_heq
a'
this
h₁
noConfusionType
v1
P
n_eq
v2
noConfusion
h12
h1a
h11
pred_le_pred
match_1
_@
Init
Prelude
_hyg
h_3
h_2
h_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
outParam
EStateM
Backtrackable
mk
restore
save
σ
δ
rec
casesOn
mk
noConfusionType
restore_eq
save_eq
noConfusion
Subsingleton
rec
LT
mk
lt
lt
lt
instLTNat
Fin
mk
isLt
val
Iff
intro
Core
_hyg
mpr
mp
propext
propIntro
h₂
rec
casesOn
noConfusionType
val_eq
noConfusion
casesOn
injEq
_@
Init
Core
_hyg
Core
_hyg
HPow
mk
w
hPow
γ
hPow
Pow
mk
pow
pow
instHPow
u_2
inst
_@
Init
Prelude
_hyg
NatPow
mk
pow
instPowNat
PUnit
unit
PProd
mk
snd
fst
below
brecOn
F_1
Unit
unit
pow
match_1
mul
match_1
add
match_1
instNatPowNat
BitVec
ofFin
toFin
UInt32
ofBitVec
toBitVec
Or
inl
inr
And
intro
right
left
isValidChar
val
toFin
toNat
toBitVec
toNat
isValidChar
Char
mk
valid
rec
recOn
DoResultPRBC
rec
Lean
Name
anonymous
List
nil
cons
tail
head
String
mk
data
str
str
pre
num
i
rec
casesOn
num
anonymous
pre_ih
sizeOf
match_1
SizeOf
_hyg
_@
Init
SizeOf
_hyg
_@
Init
SizeOf
_hyg
_@
Init
SizeOf
_hyg
mp
rfl
ForInStep
done
yield
rec
casesOn
yield
done
noConfusionType
a_eq
_@
Init
Core
_hyg
noConfusion
inj
Core
_hyg
OrOp
mk
or
rec
casesOn
noConfusionType
or_eq
noConfusion
Inhabited
mk
default
default
instInhabitedForall
ParserDescr
const
name
unary
p
binary
p₁
SyntaxNodeKind
node
prec
kind
trailingNode
symbol
Bool
false
true
nonReservedSymbol
includeIdent
cat
rbp
catName
parser
nodeWithAntiquot
optParam
sepBy
allowTrailingSep
psep
sep
sepBy1
TrailingParserDescr
mkStr1
s₁
term_\/_
HMul
mk
hMul
rec
casesOn
noConfusionType
hMul_eq
Task
Priority
max
MonadExceptOf
mk
handler
body
tryCatch
throw
ε
Result
ok
error
throw
e
s
save
rec
casesOn
error
ok
tryCatch
match_1
restore
handle
d
instMonadExceptOfOfBacktrackable
_@
Init
Prelude
_hyg
HAndThen
mk
hAndThen
rec
casesOn
noConfusionType
hAndThen_eq
noConfusion
intro
allEq
False
Not
id
not_false
sizeOf
match_1
SizeOf
_hyg
Functor
mk
mapConst
map
Pure
mk
pure
Seq
mk
seq
SeqLeft
mk
seqLeft
SeqRight
mk
seqRight
Applicative
mk
toSeqRight
toSeqLeft
toSeq
toPure
toFunctor
Bind
mk
bind
Monad
mk
toBind
toApplicative
ReaderT
map
toFunctor
toApplicative
mapConst
instFunctorOfMonad
r
_@
Init
Prelude
_hyg
pure
toPure
pure
seq
toSeq
seqLeft
toSeqLeft
seqRight
toSeqRight
instApplicativeOfMonad
Sum
inl
inr
rec
casesOn
inr
inl
noConfusionType
noConfusion
inj
rec
casesOn
true
false
ne_true_of_eq_false
match_1
EmptyCollection
mk
emptyCollection
Insert
mk
insert
Singleton
mk
singleton
insert
emptyCollection
singleton
LawfulSingleton
mk
insert_empty_eq
Core
_hyg
Decidable
isFalse
isTrue
rec
casesOn
isTrue
isFalse
if_neg
match_1
hc
c
Prod
mk
rec
casesOn
instSubsingletonProd
match_1
_@
Init
Core
_hyg
_@
Init
Core
_hyg
val
rec
absurd
casesOn
eq_of_val_eq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
val_ne_of_ne
h'
mkStr4
s₃
s₂
s₄
Parser
Tactic
allGoals
Array
mk
toList
Syntax
missing
Pos
mk
byteIdx
Substring
mk
stopPos
startPos
SourceInfo
original
endPos
trailing
pos
leading
synthetic
canonical
none
node
args
info
atom
Preresolved
namespace
ns
decl
fields
ident
preresolved
rawVal
SepArray
mk
elemsAndSeps
rec
casesOn
SyntaxNodeKinds
TSyntax
mk
raw
ks
instInhabitedSyntax
instInhabitedTSyntax
HasSubset
mk
Subset
rec
casesOn
Append
mk
append
HAppend
mk
hAppend
append
instHAppendOfAppend
elim
term_∘_
Membership
mk
mem
rec
casesOn
noConfusionType
mem_eq
MonadFunctor
rec
hash
match_1
interpolatedStrLitKind
emptyRelation
Std
LeftIdentity
mk
o
op
Identity
mk
toLeftIdentity
rec
recOn
dite
instDecidableIff
_proof_5
hq
hp
q
_proof_6
mpr
_proof_7
_proof_8
rec
Complement
mk
complement
rec
recOn
Function
comp
g
const
const_comp
u_3
Subtype
mk
property
Nonempty
intro
NonemptyType
val
type
type
instInhabitedNonemptyType
_private
Init
Prelude
Lean
Macro
MethodsRefPointed
MethodsRef
MacroScope
Macro
Context
mk
ref
maxRecDepth
currRecDepth
currMacroScope
mainModule
methods
maxRecDepth
posConfigItem
negConfigItem
mkStr2
valConfigItem
configItem
optConfig
simpErase
simpPre
simpPost
simpLemma
dsimpArg
dsimpArgs
locationWildcard
locationType
locationHyp
location
dsimpTraceArgsRest
dsimpTrace
rec
recOn
appendCore
match_1
Prelude
_hyg
Prelude
_hyg
Prelude
_hyg
rec
recOn
unit
pure
get
rec
casesOn
noConfusionType
term_^^^_
Thunk
mk
fn
Core
Thunk
fn
get
CoeDep
mk
coe
Coe
_hyg
rec
casesOn
noConfusionType
coe_eq
noConfusion
rewrites_forbidden
Ne
DoResultPR
pure
return
rec
casesOn
return
noConfusionType
noConfusion
rec
casesOn
intro
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
trans
traceMessage
Mod
mk
mod
HMod
mk
hMod
mod
instHMod
MonadState
mk
modifyGet
set
rec
recOn
insert_empty_eq
insert_emptyc_eq
rec
recOn
Max
mk
max
rec
casesOn
noConfusionType
rec
below
tail_ih
brecOn
casesOn
cons
nil
length
match_1
as
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
HAdd
mk
hAdd
hAdd
Add
mk
add
add
instHAdd
instAddNat
toList
size
pred
_
sub
Min
mk
min
min
DecidableRel
ite
minOfLe
y
beq
match_1
h_4
ble
DecidableEq
decEq
match_1
_@
Init
Prelude
_hyg
noConfusionType
noConfusion
instDecidableEqBool
le_of_ble_eq_true
match_1
zero_le
match_1
below
refl
_@
Init
Prelude
_hyg
step
brecOn
ih
_@
Init
Prelude
_hyg
rec
casesOn
succ_le_succ
match_1
_@
Init
Prelude
_hyg
h_below
_@
Init
Prelude
_hyg
funType
ble_eq_true_of_le
match_1
_@
Init
Prelude
_hyg
ble_self_eq_true
match_1
ble_succ_eq_true
match_1
not_le_of_not_ble_eq_true
decLe
instMinNat
decLt
appendCore
loop
match_1
concat
match_1
push
elim
C
get
match_1
_@
Init
Prelude
_hyg
le_trans
match_1
_@
Init
Prelude
_hyg
k
_@
Init
Prelude
_hyg
le_succ
le_of_succ_le_succ
_proof_34
getInternal
extract
loop
bs
j
i'
hlt
emptyWithCapacity
stop
start
sz'
BEq
mk
beq
beq
ReflBEq
mk
LawfulBEq
mk
eq_of_beq
toReflBEq
decide
instBEqOfDecidableEq
of_decide_eq_self_eq_true
match_1
of_decide_eq_true
match_1
decide_eq_false
match_1
instLawfulBEq
Core
_hyg
decide
ShiftLeft
mk
shiftLeft
rec
recOn
Exception
error
unsupportedSyntax
State
mk
traceMsgs
macroScope
MacroM
Option
none
some
Methods
mk
resolveGlobalName
resolveNamespace
hasDecl
getCurrNamespace
expandMacro?
rec
casesOn
tacticRfl'
rec
casesOn
noConfusionType
fn_eq
noConfusion
rec
casesOn
noConfusionType
noConfusion
inj
byteIdx_eq
_@
Init
Core
_hyg
term_⊂_
Category
mk
stx
IdempotentOp
mk
idempotent
rec
casesOn
noConfusionType
noConfusion
apply?
HShiftLeft
mk
hShiftLeft
rec
casesOn
noConfusionType
SizeOf
mk
sizeOf
sizeOf
_sizeOf_1
_sizeOf_inst
sizeOf_spec
changeWith
rec
noConfusionType
str_eq
pre_eq
i_eq
rec
casesOn
none
synthetic
original
getTrailing?
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
ndrec
rec
casesOn
elim
match_1
rec
casesOn
noConfusionType
raw_eq
noConfusion
attr
rec
below
brecOn
rec
_sizeOf_1
SizeOf
_hyg
_sizeOf_inst
rec
rec
instSizeOfNat
instSizeOfDefault
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
instSizeOfName
_sizeOf_1
_sizeOf_inst
_sizeOf_1
p_ih
p₂_ih
p₁_ih
p₂
lhsPrec
psep_ih
_sizeOf_inst
sizeOf_spec
Sub
mk
sub
rec
recOn
DoResultBC
break
continue
rec
casesOn
continue
break
noConfusionType
noConfusion
injEq
modifyGet
modify
_sizeOf_1
_sizeOf_inst
sizeOf_spec
NonScalar
rec
discharger
simpStar
simpArg
simpArgs
simpaArgsRest
tacticSimpa?!_
tacticAdmit
Neg
mk
neg
rec
casesOn
noConfusionType
neg_eq
prec(_)
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
tacticHave'_:=_
instDecidableAnd
match_1
dq
_@
Init
Prelude
_hyg
right
_proof_2
left
_proof_3
dp
_@
Init
Prelude
_hyg
UInt64
size
decidable_of_decidable_of_iff
_proof_2
rec
casesOn
noConfusionType
noConfusion
hMod_eq
withReducible
stx_?
recOn
CoeOTC
mk
rec
casesOn
noConfusionType
MacroScopesView
mk
scopes
imported
rec
casesOn
noConfusionType
scopes_eq
mainModule_eq
imported_eq
name_eq
noConfusion
ofNatLT
rec
casesOn
noConfusionType
toSeqRight_eq
toSeqLeft_eq
toSeq_eq
toPure_eq
toFunctor_eq
Associative
rec
term_⊃_
TSepArray
mk
rec
casesOn
noConfusionType
elemsAndSeps_eq
split
HDiv
mk
hDiv
rec
recOn
Equivalence
mk
z
trans
symm
Setoid
mk
iseqv
HasEquiv
mk
Equiv
Equiv
r
instHasEquivOfSetoid
Quot
Quotient
lift
lift
refl
iseqv
refl
lift₂
_proof_29
b₂
a₂
b₁
a₁
φ
mk
mk
ind
ind
_proof_30
q₂
uA
uB
uC
q₁
rec
recOn
startPos
rec
casesOn
skip
rfl
rfl
refl
Mul
mk
mul
rec
casesOn
noConfusionType
Div
mk
div
rec
recOn
rec
below
motive_3
motive_2
motive_1
args_ih
head_ih
rec_1
below_1
rec_2
below_2
brecOn_1
F_3
F_2
toList_ih
pure
return
break
continue
casesOn
noConfusionType
noConfusion
strLitKind
imp_intro
casesOn
noConfusionType
pow_eq
PSum
inl
inr
rec
casesOn
noConfusionType
congr
f₂
f₁
simpTraceArgsRest
simpTrace
dcond
match_1
_@
Init
Prelude
_hyg
rec
casesOn
rec
casesOn
noConfusionType
r_eq
noConfusion
tacticAc_nf_
inline
eq_1
rec
casesOn
noConfusionType
Equiv_eq
lt_of_le_of_lt
intro_left
noConfusionType
tail_eq
head_eq
noConfusion
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
ndrecOn
subst
byteIdx
instHAddPos
byCases
match_1
h2
h1
dec
_@
Init
Core
_hyg
em
RightIdentity
rec
mkNum
instDecidableEqSum
match_1
Core
_hyg
casesOn
noConfusionType
insert_eq
noConfusion
True
intro
ibelow
rec
rec
casesOn
noConfusionType
rec
casesOn
noConfusionType
noConfusion
coeNotation
comp_def
instSubsingletonDecidable
match_1
instLEBitVec
x2
_@
Init
Prelude
_hyg
x1
_@
Init
Prelude
_hyg
instLEUInt32
size
ofNatLT
utf8Size
_proof_25
inferInstanceAs
instDecidableLeBitVec
decLe
instDecidableLeUInt32
_proof_26
_proof_27
noConfusionType
resolveGlobalName_eq
resolveNamespace_eq
hasDecl_eq
getCurrNamespace_eq
expandMacro?_eq
Zero
mk
rec
casesOn
noConfusionType
noConfusion
noConfusion
sizeOf_spec
term_∪_
SDiff
mk
sdiff
MonadWithReaderOf
mk
withReader
rec
casesOn
noConfusionType
withReader_eq
noConfusion
if_pos
match_1
symm
symm
hab
noConfusionType
snd_eq
fst_eq
noConfusion
instLEPos
instDecidableLePos
readThe
rec
casesOn
noConfusionType
noConfusion
UInt16
ofBitVec
rec
casesOn
ofBitVec
noConfusionType
toBitVec_eq
noConfusion
MonadReader
rec
casesOn
noConfusionType
_sizeOf_1
_sizeOf_inst
sizeOf_spec
ref
interpolatedStrKind
term_==_
rec
rec
recOn
rec
casesOn
elim
match_1
_@
Init
Prelude
_hyg
instNonemptyPProd
tacticSuffices_
le_antisymm
match_1
not_succ_le_self
match_1
not_succ_le_zero
match_3
match_1
match_2
lt_irrefl
HasSSubset
mk
SSubset
rec
casesOn
noConfusionType
SSubset_eq
noConfusion
rec
casesOn
noConfusionType
noConfusion
casesOn
some
getTrailingTailPos?
match_1
rec
recOn
Relation
TransGen
single
tail
flip
imp
swap
imp_not_comm
intro
recOn
MonadRef
rec
instSizeOfForallUnit
_sizeOf_1
_sizeOf_inst
sizeOf_spec
System
Platform
getNumBits
_proof_5
GE
ge
lt_or_ge
match_2
HAnd
mk
hAnd
rec
casesOn
noConfusionType
noConfusion
USize
size_pos
match_1
choiceKind
CoeTail
mk
rec
casesOn
ShiftRight
mk
shiftRight
rec
casesOn
noConfusionType
tacticLetI_
Except
error
ok
rec
casesOn
UInt8
ofBitVec
rec
casesOn
noConfusionType
noConfusion
injEq
_@
Init
Core
_hyg
rec
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
stopPos
getPos?
match_1
canonicalOnly
_@
Init
Prelude
_hyg
getTailPos?
LawfulLeftIdentity
mk
left_id
CoeT
mk
cond
match_1
hasMacroScopes
match_1
casesOn
decEq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
hasDecEq
match_3
_proof_28
_proof_29
_proof_30
match_2
nab
decEq
match_1
habs
nabs
_proof_31
_proof_32
_proof_33
instDecidableEqList
instDecidableEqChar
match_1
decEq
match_1
_@
Init
Prelude
_hyg
casesOn
ofFin
decEq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
instDecidableEqFin
match_1
decEq
match_1
eq_of_beq_eq_true
match_1
ne_of_beq_eq_false
match_1
instDecidableEqNat
eq_of_val_eq
match_1
val_eq_of_eq
_proof_6
_proof_7
noConfusionType
toFin_eq
noConfusion
_proof_8
instDecidableEqBitVec
_proof_15
noConfusion
_proof_16
instDecidableEqUInt32
val_eq_of_eq
match_1
ne_of_val_ne
congrArg
_proof_35
noConfusionType
data_eq
noConfusion
_proof_36
instDecidableEqString
eraseMacroScopesAux
match_1
eraseMacroScopes
numBits
ofBitVec
rec
casesOn
decEq
match_1
toBitVec
mk
instCoeHTC
casesOn
noConfusionType
noConfusion
ForIn
mk
u₁
u₂
xs
forIn
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
sizeOf_spec
Commutative
rec
DecideConfig
mk
revert
zetaReduce
native
kernel
rec
casesOn
noConfusionType
revert_eq
zetaReduce_eq
native_eq
kernel_eq
noConfusion
OrElse
mk
orElse
MonadStateOf
mk
casesOn
noConfusionType
toList_eq
noConfusion
injEq
_@
Init
Core
_hyg
mk
assoc
casesOn
noConfusionType
noConfusionType
noConfusion
comp_const
map
Pi
instInhabited
CoeTC
mk
rec
casesOn
noConfusionType
noConfusion
rec
casesOn
noConfusionType
seqLeft_eq
noConfusion
liftOn
sound
funext
extfunApp
eqv
instInhabitedOption
getHeadInfo?
inj
change
mkArray2
trivial
of_iff_true
rec
builtin_command_code_action
nullKind
casesOn
noConfusionType
PSigma
mk
rec
casesOn
Exists
of_psigma_prop
match_1
hx
toBoolUsing
decide_eq_true
match_1
toBoolUsing_eq_true
imp_congr_left
mt
ha
refl
rfl
of_eq
neq_of_not_iff
mkArray5
a₅
a₄
a₃
irrefl
term∅
sizeOf_spec
inferInstance
instLawfulBEqChar
of_toBoolUsing_eq_true
ofBoolUsing_eq_true
id_eq
Xor
mk
xor
rec
casesOn
inhabitedLeft
structInstFieldDecl
substVars
instInhabited
brecOn_2
eqRec_heq
match_1
_@
Init
Core
_hyg
One
mk
one
rec
recOn
CoeSort
mk
rec
casesOn
noConfusionType
rec
casesOn
noConfusionType
binderIdent
renameI
inj
instBEq
instReflBEq
MProd
mk
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
instDecidableEqPos
match_2
symm
comm
or_comm
stx_+
trans
subst
heq_of_eq
heq_of_eq_of_heq
ndrecOn
fst
indep
eta
indepCoherent
liftIndepPr1
snd
rec
allEq
elim
recOnSubsingleton
_proof_27
_@
Init
Core
_hyg
recOnSubsingleton
Empty
rec
mem
ForIn'
mk
forIn'
rec
recOn
stx_,*
casesOn
ident
atom
node
missing
getKind
match_1
stx
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
recOn
AndOp
mk
and
rec
casesOn
noConfusionType
noConfusion
PEmpty
MonadLiftT
mk
monadLift
rec
casesOn
noConfusionType
monadLift_eq
noConfusion
rec
elim
H1
H2
iff_of_false
hb
iff_false_left
Total
mk
total
total
decide_false
match_1
decide_false_eq_false
sound
CoeHTCT
mk
ofBitVec
rec
recOn
noConfusion
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
noConfusionType
args_eq
kind_eq
info_eq
preresolved_eq
rawVal_eq
noConfusion
injEq
_@
Init
Core
_hyg
tacticAssumption_mod_cast_
noConfusion
inj
MonadEvalT
mk
monadEval
rec
casesOn
noConfusionType
noConfusion
cast_heq
match_1
Core
_hyg
ULift
rec
bvNormalizeMacro
mk
comm
mk
LawfulRightIdentity
mk
right_id
toRightIdentity
LawfulIdentity
mk
toLawfulRightIdentity
toLawfulLeftIdentity
toIdentity
LawfulCommIdentity
mk
toLawfulIdentity
mkStr3
timeCmd
HomogeneousPow
mk
pow
term_∩_
byContradiction
np
noConfusionTypeEnum
intro
precMin
instNonemptyMProd
coe
elemsAndSeps
fst
snd
lexLt
rec
subst
getCurrNamespace
DoResultSBC
pureReturn
break
continue
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
apply
inductionOn₂
casesOn
noConfusionType
pure_eq
noConfusion
shiftLeft
instHShiftLeftOfShiftLeft
Union
mk
union
union
rotateRight
inductionAltLHS
inductionAlt
throw
throwThe
coe
instCoeTOfCoeHTCT
Coe
_hyg
inj
inductionOn
exists_rep
contradiction
coe
thunkCoe
MonadExcept
ofExcept
match_1
tacticLet_
mkArray3
node3
noConfusionType
casesOn
subsingleton
_@
Init
Core
_hyg
PNonScalar
mk
rec
casesOn
noConfusionType
intro
inj
_@
Init
Core
_hyg
_@
Init
Core
_hyg
inj
_@
Init
Core
_hyg
comm
mk
casesOn
noConfusionType
noConfusion
monadEval
congr
AndThen
mk
andThen
andThen
instHAndThenOfAndThen
HOrElse
mk
hOrElse
rec
casesOn
noConfusionType
rec
recOn
Hashable
mk
hash
ofNatLT
instInhabitedUInt64
_proof_20
hash
instHashableString
injEq
groupKind
rec
casesOn
noConfusionType
HXor
mk
hXor
hXor
hAndThen
mk'
bind
toBind
bind
instMonad
bind
match_1
map
pure
seqRight
instMonad
mk
read
instMonadReaderOfMonadReaderOf
read
instMonadReaderOfReaderTOfMonad
extractMacroScopesAux
match_1
acc
scp
namedPattern
extractImported
match_1
parts
assembleParts
match_1
ps
mkStr
panicCore
msg
panic
instInhabitedName
instInhabitedList
instInhabitedMacroScopesView
scps
extractMainModule
extractMacroScopes
beq
match_1
n₂
n₁
and
match_1
instBEq
mainModule
review
match_1
scopes
name
imported
foldl
match_1
l
init
base
view
addMacroScope
mainModule
currMacroScope
addMacroScope
ctx
term_↔_
mkArray1
node1
noConfusionType
term_<*_
tacticExfalso
size
size_eq
match_1
property
numBits_eq
empty
raw
mkNode
mkNullNode
ne_false_of_eq_true
match_1
instDecidableForall
_proof_4
term_<*>_
tacticTry_
coe
Internal
coeM
instInhabitedSubstring
coe
instCoeHTCOfCoeOTC
rec
utf8ByteSize
match_1
go
match_1
cs
instHAddPosString
casesOn
rec
recOn
Irrefl
mk
irrefl
rec
casesOn
HOr
rec
mul
sub
rec
casesOn
noConfusionType
toBind_eq
toApplicative_eq
noConfusion
decEq
match_1
_proof_12
_proof_13
Attr
wf_preprocess
boolToSort
rec
casesOn
instDecidableEqOfLawfulBEq
match_1
trans
not_eq_of_beq_eq_false
toReflBEq
_proof_1
eq_of_beq
stx_*
noConfusionType
noConfusion
inj
recOn
CoeOut
mk
subtypeCoe
heq_of_eqRec_eq
caseArg
case'
casesOn
noConfusionType
noConfusion
inj
_sizeOf_1
_sizeOf_inst
_sizeOf_2
_sizeOf_3
_sizeOf_3_eq
sizeOf_spec
_sizeOf_2_eq
sizeOf_spec
recOn
mk
withRef
getRef
MonadQuotation
mk
withFreshMacroScope
getMainModule
getCurrMacroScope
toMonadRef
rec
recOn
elim
Subrelation
Asymm
mk
asymm
get
getThe
set
modifyGet
instMonadStateOfMonadStateOf
MonadLift
mk
monadLift
liftM
monadLift
instMonadLiftTOfMonadLift
u_4
instMonadLiftT
instMonadStateOfOfMonadLift
instMonadLift
get
set
modifyGet
match_1
Prelude
_hyg
instMonadStateOf
macroScope
traceMsgs
trace
clsName
instMinPos
noConfusion
instHAddPosChar
mk
rec
casesOn
instDecidableFalse
normCastLabel
first
dummyRestore
isLt
zetaReduce
rec
recOn
tacticRefine_lift_
ibelow_2
decidable_of_decidable_of_eq
_proof_3
inj
trans
trans
hbc
rec
casesOn
noConfusionType
ofNatLT
casesOn
noConfusionType
rec
recOn
iff_false_intro
not_not_intro
hn
not_iff_false_intro
ne_self_iff_false
rec
casesOn
noConfusionType
modifyGet_eq
set_eq
get_eq
instDecidableEqProd
match_2
map
v₁
v₂
β₂
β₁
α₂
α₁
map_apply
rec
sizeOf_spec
mixHash
not_congr
rec
casesOn
recOn
coe
iff_of_true
iff_true_intro
imp_true_iff
_sizeOf_1
_sizeOf_inst
sizeOf_spec
dif_eq_if
match_1
recOn
term_&&&_
Squash
mk
ind
instSubsingletonSquash
getTailPos?
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
h_11
h_10
h_9
h_8
h_7
h_6
h_5
refine
instMonadReaderOfOfMonadLift
trustCompiler
reduceNat
ofReduceNat
rec
casesOn
guardMsgsFilterSeverity
guardMsgsFilter
instInhabitedPProd
instDecidableEqUInt16
inhabitedRight
recOn
exists_of_subtype
match_1
inj
term¬_
casesOn
noConfusionType
read_eq
noConfusion
rec
casesOn
single
Core
_hyg
noConfusion
prec
recOn
get
instInhabitedNat
instInhabitedState
MonadWithReader
mk
rec
casesOn
noConfusionType
noConfusion
recOn
CoeFun
mk
coe
recOn
casesOn
withAnnotateTerm
recOn
getRef
fromRef
match_1
tailPos
loop
match_1
getHeadInfo
getPos?
match_2
noncanonical
mkInfoFromRefPos
__do_lift
_@
Init
Prelude
_hyg
command
hDiv
rec
recOn
instPowOfHomogeneousPow
getInfo?
match_1
symm
comm
Syntax
addPrio
casesOn
bsize
match_1
runTac
Sep
mk
rec
casesOn
noConfusionType
sep_eq
rec
casesOn
Trans
mk
not_not_not
term_<_
recOn
term_=_
rec
casesOn
noConfusionType
casesOn
elim
match_1
instSubsingletonPEmpty
sizeOf_spec
term_-_
casesOn
noConfusionType
noConfusionType
noConfusion
inj
indBeta
rec
casesOn
unsupportedSyntax
noConfusionType
Prelude
_hyg
noConfusion
recOn
casesOn
recOn
eq_true_of_ne_false
match_1
injEq
casesOn
pureReturn
noConfusionType
noConfusion
not
symm
match_1
comm
and_comm
tacticShow_
casesOn
noConfusionType
rec
Coe
mk
coe
noConfusionType
rec
casesOn
Classical
choice
ofNonempty
_proof_1
instNonemptyTask
Core
_hyg
default
get
map
sync
prio
rec
generalizeArg
generalize
le_of_le_of_eq
instDecidableOr
match_1
_proof_4
lexLtDec
replaceRef
match_1
oldRef
withRef
withRef
sizeOf_spec
declName
rec
dif_neg
match_1
hnc
ibelow
ibelow_1
binductionOn
simpMacroScopesAux
match_1
simpMacroScopes
paren
ibelow
noConfusionType
mapConst_eq
map_eq
noConfusion
term_/_
rec
casesOn
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
Sigma
mk
rec
casesOn
noConfusionType
rec
casesOn
noConfusionType
traceMsgs_eq
macroScope_eq
noConfusion
guardMsgsWhitespaceArg
guardMsgsWhitespace
guardMsgsOrderingArg
guardMsgsOrdering
guardMsgsSpecElt
guardMsgsSpec
guardMsgsCmd
noConfusion
inj
Init
Core
_hyg
inj
_@
Init
Core
_hyg
rec
casesOn
elim
match_1
Core
_hyg
match_1
rec
size
casesOn
recOn
recOn
noConfusionType
endPos_eq
trailing_eq
pos_eq
leading_eq
canonical_eq
noConfusion
instDecidableTrue
falseOrByContra
le_of_lt_succ
casesOn
noConfusionType
noConfusion
rec
casesOn
noConfusionType
tryCatch_eq
throw_eq
noConfusion
set
match_1
casesOn
noConfusion
inj
injEq
intro
recOn
instInhabitedSort
below
brecOn
mk
monadMap
casesOn
noConfusionType
monadMap_eq
rec
casesOn
noConfusionType
noConfusion
injEq
rec
casesOn
done
noConfusion
injEq
_sizeOf_1
_sizeOf_inst
sizeOf_spec
inj
rawStx
quot
casesOn
casesOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
reservedMacroScope
firstFrontendMacroScope
casesOn
noConfusionType
bind_eq
HSub
mk
hSub
instHSub
recOn
liftBeta
up
down
casesOn
up
noConfusionType
down_eq
noConfusion
noConfusionType
noConfusion
injEq
Init
Core
_hyg
Init
Core
_hyg
noConfusionType
stopPos_eq
startPos_eq
noConfusion
term_>>>_
recOn
zero
MonadEval
mk
monadEval
instMonadEvalTOfMonadEval
includeStr
inj
rec
recOn
hMul
inj
sizeOf_spec
term_&&_
rec
casesOn
recOn
recOn
hrecOn
_proof_28
hrecOn
term_∉_
casesOn
noConfusionType
rec
recOn
exists_rep
noConfusionType
mk
hOr
casesOn
noConfusionType
noConfusion
sizeOf_spec
tacticExists_,,
isMissing
match_1
injEq
of_decide_eq_false
match_1
rec
recOn
casesOn
sizeOf_spec
MonadFunctorT
mk
monadMap
_sizeOf_1
_sizeOf_inst
_sizeOf_1
_sizeOf_inst
sizeOf_spec
as_aux_lemma
prioHigh
exposeNames
casesOn
noConfusionType
noConfusion
hygieneInfoKind
inhabitedRight
_proof_40
_proof_41
instHashableName
injEq
rawNatLit
recOn
recOn
spawn
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
recOn
inj
lt_of_lt_of_eq
instInhabitedBool
withReader
withReader
withTheReader
instMonadWithReaderOfMonadWithReaderOf
instMonadWithReaderOfReaderT
methods
currRecDepth
withFreshMacroScope
fresh
tacticRepeat_
checkSimpFailure
anyGoals
sizeOf_spec
autoParam
tactic
rec
casesOn
acRfl
decide_true
match_1
heq_self_iff_true
below
rec
coe
PLift
up
rec
casesOn
instMonadEvalT
boolToProp
recOn
rwRule
rwRuleSeq
proof_irrel
instSubsingleton
recOnSubsingleton₂
_proof_32
t₁
t₂
decidableEq
_proof_33
match_1
liftOn₂
Quotient
rel
_proof_31
a₂b₂
a₁b₁
a₁a₂
b₁b₂
inductionOn
refl
rel_of_eq
exact
_proof_34
type_eq_of_heq
inj
eq_or_lt_of_le
match_2
recOn
symm
comm
iff_false_right
CoeHead
mk
rec
recOn
injEq
bvTraceMacro
maxOfLe
instMaxUInt32
noConfusionType
default_eq
noConfusion
instInhabitedReaderT
instInhabitedOfMonad
instInhabitedMethods
snd
modifyGetThe
rec
noConfusion
not_and_iff_or_not
match_2
throw
tryCatch
tryCatchThe
instMonadExceptOfMonadExceptOf
instMonadExceptOf
dummySave
nonBacktrackable
throwUnsupported
casesOn
recOn
checkTacticFailure
iff_not_self
H
mkStr5
s₅
SolveByElim
star
erase
arg
args
inj
noConfusionType
term_%_
modifyThe
casesOn
noConfusionType
casesOn
noConfusionType
noConfusion
Refl
mk
rec
recOn
casesOn
mkAtomFrom
src
mkArray6
a₆
node6
down
term_⊕'_
run
injEq
casesOn
noConfusionType
symm
term_<|_
imp_congr_right
hcd
imp_congr_ctx
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
casesOn
noConfusionType
instNonemptyOfMonad
match_1
liftOn
noConfusionType
neg_resolve_left
pushCast
setKind
match_1
getD
v₀
get!Internal
getOptional?
noConfusion
sizeOf_default
DecidableLT
toRightIdentity
noConfusionType
complement
noConfusion
dsimp
term
instLTBitVec
term!_
imp_imp_imp
h₀
recOn
noConfusionType
noConfusion
recOn
beq_of_eq
match_1
beq_iff_eq
recOn
recOn
inj
append
match_1
instAppendName
termIfLet
not_true
ne_of_beq_false
noConfusion
injEq
hasDecl
recOn
false_iff_true
xor
coe
instCoeOTCOfCoeOut
max
instDecidableEq
match_1
cast_eq
recOn
down
tacticLet'_
sizeOf_spec
eq_self_iff_true
inj
tactic_<;>_
rec
HShiftRight
mk
hShiftRight
hShiftRight
Inter
mk
inter
inter
tacticAnd_intros
rec
recOn
Dvd
mk
dvd
using_
applyRules
ge_iff_le
sizeOf_spec
of_toBoolUsing_eq_false
add_zero
sizeOf_spec
size
noConfusion
recOn
elimTarget
recOn
mkStr7
s₇
s₆
rec
casesOn
noConfusionType
ref_eq
maxRecDepth_eq
currRecDepth_eq
currMacroScope_eq
methods_eq
instMulNat
single
Core
_hyg
tail
casesOn
injEq
solveByElim
recOn
noConfusion
tacticNorm_cast__
noConfusionType
noConfusion
heq_comm
casesOn
noConfusionType
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
noConfusionType
noConfusion
noConfusion
sizeOf_spec
resolveGlobalName
noConfusion
zero_lt_succ
coeSortNotation
instCoeSyntaxNodeKindSyntaxNodeKinds
getMethods
resolveGlobalName
injEq
scientificLitKind
term_++_
tacticGet_elem_tactic
noConfusionType
noConfusion
iff_comm
instCommutativeIff
getModify
casesOn
instMonadFunctor
eq
match_1
_@
Init
Core
_hyg
TSyntaxArray
mk
down_up
false_imp_iff
noConfusionEnum
_proof_9
casesOn
noConfusionType
sizeOf_spec
refine'
injEq
noConfusionType
recOn
recOn
SSubset
SSuperset
recOn
insert_emptyc_eq
monadMap
instMonadFunctorTOfMonadFunctor
monadFunctorRefl
instMonadWithReaderOfOfMonadFunctor
rec
casesOn
recOn
tacticDsimp?!_
level
_sizeOf_1
_sizeOf_inst
sizeOf_spec
tacticSimp?!_
instHMul
sep
casesOn
noConfusionType
toMonadRef
a2
a1
instLawfulBEq
prioMid
prio
recOn
noConfusionType
recOn
rec
noConfusion
toIdentity
endPos
toSubstring
Attr
coe
recOn
heq_of_heq_of_eq
b'
id_def
term_⊕_
recOn
iff_true_left
tacticSimpa?_
casesOn
noConfusionType
noConfusion
rec
recOn
recOn
existsOfSubtype
tacticNext_=>_
unfold
casesOn
sepBy1
sepBy
nodeWithAntiquot
parser
cat
nonReservedSymbol
symbol
trailingNode
binary
unary
const
iff_of_eq
charLitKind
recOn
term_>>_
mkSimple
identKind
isOfKind
getNumArgs
isNodeOf
helim
data
recOn
sizeOf_spec
decEq
match_1
_proof_9
_proof_10
instDecidableEqUInt8
mkArray4
node4
rec
instSubsingleton
_proof_37
_proof_38
he
match_1
noConfusion
Antisymm
mk
antisymm
rec
casesOn
recOn
casesOn
noConfusionType
seqRight_eq
term_>_
noConfusionType
noConfusion
mkArray0
set
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
rec
recOn
noConfusionType
noConfusion
le_of_eq_of_le
dedicated
repeat'
injEq
noConfusion
inj
term‹_›
replace
casesOn
decl
namespace
noConfusionType
ns_eq
fields_eq
injEq
_@
Init
Core
_hyg
noConfusion
exact?
node5
noConfusion
_sizeOf_1
_sizeOf_inst
sizeOf_spec
norm_cast
injEq
rec
recOn
imp_false
recOn
decEq
match_1
_proof_18
noConfusionType
noConfusion
_proof_19
neg
reduceCmd
inj
getMainModule
valid
node2
getD
match_1
opt
_@
Init
Prelude
_hyg
map
match_3
term_>>=_
letrec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
recOn
map_snd
false_of_ne
sizeOf_spec
casesOn
noConfusionType
sizeOf_eq
noConfusion
sizeOf_thunk
recOn
match_1
resolve_left
na
sizeOf_spec
iff_iff_eq
precMax
instDecidableNot
toLeftIdentity
substr
PrettyPrinter
UnexpandM
instMonadQuotationUnexpandM
toBitVec
noConfusion
deprecated
noConfusionType
noConfusion
symmSaturate
revert
inj
noConfusionType
noConfusion
instInhabitedUSize
inductionAlts
instNonemptyMethodsRef
mkMethods
instInhabitedMethodsRef
antisymm
inj
strictAnd
tacticBv_omega
rwSeq
rec
casesOn
tacticSorry
prioDefault
intros
ne_true_of_not
hnp
binductionOn
recOn
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
casesOn
noConfusionType
getCurrNamespace
casesOn
noConfusionType
recOn
injEq
suggestPremises
eq_false_of_ne_true
match_1
casesOn
noConfusionType
withRef_eq
getRef_eq
noConfusion
recOn
injEq
noConfusionType
sizeOf_spec
noConfusion
noConfusion
casesOn
noConfusionType
noConfusion
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
normCastAddElim
simpAllTraceArgsRest
instInhabitedForInStep_1
coe
instCoeHTCTOfCoeTailOfCoeHTC
dvd
recOn
induction
hasDecl
subPrio
resolveNamespace
term_<=_
casesOn
div
instHDiv
noConfusionType
p_eq
p₂_eq
p₁_eq
prec_eq
lhsPrec_eq
includeIdent_eq
psep_eq
injections
stx_,+
symm
ne_comm
failIfSuccess
instDecidableEqOfIff
match_1
_@
Init
Core
_hyg
_proof_21
heq
orElse
x₂
x₁
injEq
recOn
rec
casesOn
noConfusionType
noConfusion
noConfusion
recOn
casesOn
casesOn
noConfusionType
beq_eq
noConfusion
injEq
Subset
Superset
noConfusion
inj
casesOn
noConfusionType
casesOn
noConfusionType
noConfusion
recOn
addPrec
instDecidableIte
dE
dT
dC
_@
Init
Core
_hyg
instSubNat
casesOn
noConfusionType
dvd_eq
sizeOf_spec
withReducibleAndInstances
recOn
recOn
and
instHAndOfAndOp
noConfusionType
tacticHave'_
InvImage
instOrElseOfBacktrackable
casesOn
noConfusionType
simpAllTrace
tacticRefine_lift'_
not_of_iff_false
injEq
instLawfulBEqString
inj
recOn
toLawfulLeftIdentity
recOn
focus
sizeOf_spec
exact?
optParam_eq
_proof_10
_proof_11
injEq
Init
Core
_hyg
Init
Core
_hyg
tacticTrivial
sizeOf_spec
elim
instSubsingletonEmpty
coeFunNotation
casesOn
recOn
cases
elim
recOn
stx!_
runElab
injEq
expandMacro?
rec
sizeOf_spec
recOn
hAppend
recOn
match_1
instNonempty
modCast
instCommutativeOr
tacticStop_
true_eq_false_of_false
instInhabitedPos
bind
recOn
ibelow
binductionOn
casesOn
eqRefl
revert
noConfusionType
noConfusion
isIdent
match_1
noConfusion
rec
casesOn
noConfusionType
andThen_eq
dif_pos
match_1
instCoeTCOfCoe_1
iff_iff_implies_and_implies
iff_def
iff_def'
_proof_21
noConfusion
_proof_22
_sizeOf_1
_sizeOf_inst
sizeOf_spec
casesOn
ibelow
inj
nonemptyLeft
injEq
assumption
mkArray8
a₈
a₇
node8
recOn
left_id
noConfusion
getCurrMacroScope
addMacroScope
instDecidableLtBitVec
GT
gt
hAnd
false_comp
maxRecDepthErrorMessage
withIncRecDepth
term_|||_
injEq
asymm
ofNatLT
instTransEq_1
stx_,*,?
runMeta
noConfusion
match_3
shiftRight
noConfusion
lift
_proof_35
recOn
instMonadRefMacroM
throwError
rec
casesOn
casesOn
funCases
doElem
casesOn
specialize
instLTPos
instDecidableLtPos
instLEFin
nonempty_of_exists
match_1
tacticHave_
noConfusionType
seq_eq
normCast0
noConfusion
adaptExcept
match_1
bind
instInhabitedPNonScalar
simp
injEq
noConfusion
noConfusion
forIn
brecOn
imp_congr
hOr
inj
inj
_@
Init
Core
_hyg
noConfusionType
noConfusion
sizeOf_spec
instCoeTOfCoeDep
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
Antisymm
instInhabitedNonScalar
toRightIdentity
instBEqProd
term_||_
rewrites?
str
toArray
injEq
subst
injEq
recOn
loop
match_1
match_1
d₂
_@
Init
Core
_hyg
d₁
_@
Init
Core
_hyg
fieldIdxKind
precArg
stx_,+,?
casesOn
noConfusionType
tacticNomatch_,,
mpr
sizeOf_spec
term_$__
applyRfl
or
instHOrOfOrOp
instInhabitedSourceInfo
recOn
coe
inj
orElse
instHOrElseOfOrElse
recOn
term~~~_
tacticSimpa!_
recOn
simp
funInduction
rename
instDecidableEqPUnit
instCoeOutOfCoeFun
noConfusion
complement_eq
casesOn
noConfusionType
noConfusion
inj
noConfusion
term_<$>_
recOn
congrFun
withAnnotateState
toSubstring'
mkEmpty
tacticGet_elem_tactic_trivial
inj
runCmd
term_^_
Unexpander
instMonadRefOfMonadLiftOfMonadFunctor
noConfusionType
trans_eq
noConfusion
_sizeOf_1
_sizeOf_inst
sizeOf_spec
instInhabitedUInt16
_proof_14
rec
casesOn
noConfusionType
noConfusionType
noConfusion
term_::_
sizeOf_spec
withUnfoldingAll
sizeOf_eq_one
SizeOf
_hyg
SizeOf
_hyg
termIfThenElse
instMinUInt32
noConfusionType
comm
recOn
bne
term_*>_
inj
inj
instInhabitedTask
noConfusion
noConfusion
recOn
noConfusionType
recOn
toLawfulIdentity
recOn
recOn
recOn
sizeOf_spec
toLeftIdentity
recOn
right_id
sizeOf_eq
_@
Init
Core
_hyg
term{}
noConfusion
dbgTrace
discrTreeSimpKeyCmd
term_+_
tacticRfl
recOn
injEq
fail
throwErrorAt
simpAll
inj
tryCatch
orElse
recOn
sizeOf_nat
instCoeHTCTOfCoeHTC
noConfusion
noConfusion
recOn
hSub
sleep
instMaxPos
inj
term_<->_
optionCoe
idempotent
noConfusion
instNonemptyOfInhabited
getId
recOn
instDecidableEqPEmpty
recOn
mp
instInhabitedExcept
instHSubPos
recOn
term_|>_
byElab
noConfusion
inhabitedLeft
noConfusionType
noConfusion
injEq
_@
Init
Core
_hyg
term_≈_
_proof_18
e₂
e₁
_proof_19
e₂'
_proof_20
e₁'
map_fst
casesOn
noConfusionType
withFreshMacroScope_eq
getMainModule_eq
getCurrMacroScope_eq
toMonadRef_eq
noConfusion
casesOn
noConfusionType
injEq
term_×'_
infoTreesCmd
term_∣_
recOn
instLTUInt32
decLt
instDecidableLtUInt32
casesOn
noConfusionType
recOn
instCoeOTC
recOn
irrefl
noConfusion
instLawfulBEqBool
exact
ofNatLT
instInhabitedUInt8
_proof_11
run
recOn
one
binductionOn
omega
command_code_action
sizeOf_spec
hShiftLeft
withFreshMacroScope
raw
instInhabitedPUnit
sizeOf_spec
getArg
instNonemptyForall
noConfusion
getArgs
term{_:_//_}
tactic
casesOn
noConfusionType
noConfusion
recOn
recOn
inj
precMin1
instCoeTC
instSubsingletonPUnit
intro_right
injEq
term_!=_
recOn
noConfusion
matchesLit
match_1
mkAtom
simpa
termWithout_expected_type_
instInhabitedTrue
instInhabitedForallOfMonad
ε'
recOn
noConfusion
inj
recOn
injEq
recOn
mkStr8
s₈
recOn
sizeOf_spec
neg_resolve_right
nb
_sizeOf_1
_sizeOf_inst
sizeOf_spec
recOn
sizeOf_spec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
le_succ_of_le
match_1
le_refl
recOn
or
strictOr
fst
elemsAndSeps
noConfusionType
noConfusion
isValidChar_UInt32
match_1
Prelude
_hyg
Prelude
_hyg
le_step
lt_trans
ofNatAux
ofNat
_proof_23
_proof_24
_sizeOf_1
_sizeOf_inst
sizeOf_spec
term_\_
instCoeOTCOfCoeTC
noConfusion
iff_true_right
recOn
inj
instMonadEvalOfMonadLift
recOn
not_not_of_not_imp
comp_apply
expandMacro?
instNonemptyProd
noConfusion
term_×_
sizeOf_spec
imp_not_self
noConfusionType
hash_eq
noConfusion
noConfusionType
forIn_eq
recOn
term_∧_
noConfusion
noConfusionType
imp_iff_right
true_imp_iff
tacticRwa__
_sizeOf_1
_sizeOf_inst
sizeOf_spec
fst
recOn
noConfusion
rec
noConfusion
lt_of_le_of_ne
match_1
h₃
inj
noConfusion
repeat1'
instDecidableDite
recSubsingleton
h₄
instInhabitedProp
injEq
recOn
recOn
tacticUnhygienic_
term_⊆_
up_down
trans
Core
_hyg
numLitKind
noConfusionType
noConfusion
nonemptyLeft
casesOn
noConfusionType
forIn'_eq
recOn
forIn'
commandSeal__
nativeDecide
sizeOf_spec
tacticNofun
instHXorOfXor
eq_comm
recOn
eq_punit
refl
reduceBool
ofReduceBool
recOn
instHShiftRightOfShiftRight
hash
showTerm
noConfusionType
toBitVec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
inj
_proof_12
_proof_13
_proof_14
_proof_15
_proof_16
_proof_17
withRef?
match_1
ref?
_@
Init
Prelude
_hyg
not_lt_zero
recOn
recOn
noConfusionType
checkSimp
term_>=_
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
instCoeOutOfCoeSort
substEqs
term_<|>_
injEq
noConfusionType
noConfusion
not_of_not_imp
sdiff
term_≠_
term_/\_
recOn
instCoeHTCT
trans
injEq
nameLitKind
bvDecideMacro
sizeOf_spec
noConfusion
of_not_not
hnn
injEq
instMonadQuotationMacroM
instLTFin
decLt
ne_false_of_self
recOn
inj
DecidablePred
tacticSimp_all?!_
left
e_snd
e_fst
noConfusion
val'
k'
recOn
DecidableLE
recOn
recOn
subPrec
sizeOf_spec
recOn
true_iff_false
inj
config
dflt
discrTreeKeyCmd
resolve_right
recOn
recOn
mkArray7
constructor
imp_self
eq_iff_true_of_subsingleton
_sizeOf_1
_sizeOf_inst
sizeOf_spec
mkStr6
matchesNull
decLe
noConfusionType
noConfusion
sizeOf_spec
of_not_eq_false
match_1
true_ne_false
lexLt_def
instCommutativeAnd
termDepIfThenElse
pure
opaqueId
instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil
inj
instDecidableEqEmpty
prioLow
recOn
rawStx
assoc
up_down
defaultMaxRecDepth
noConfusion
inj
_sizeOf_1
_sizeOf_inst
sizeOf_spec
noConfusion
of_not_eq_true
match_1
beq_false_of_ne
_a
noConfusion
false_of_true_iff_false
sizeOf_spec
instOrElse
instInhabitedProd
noConfusion
_sizeOf_1
_sizeOf_inst
sizeOf_spec
recOn
hOrElse
eq_iff_iff
false_of_true_eq_false
noConfusion
term-_
tacticHaveI_
recOn
run'
decPropToBool
noConfusionType
singleton_eq
noConfusion
inj
recOn
instInhabitedResult
instDecidableEqUSize
sizeOf_spec
delta
instInhabitedUInt32
_proof_17
_sizeOf_1
_sizeOf_inst
sizeOf_spec
sizeOf_spec
gt_iff_lt
instDecidableEqUInt64
injEq
binductionOn_1
node7
noConfusion
resolveNamespace
noConfusion
recOn
instCoeHTCOfCoeHeadOfCoeOTC
term_≥_
recOn
toBitVec
setPremiseSelectorCmd
noConfusion
iteInduction
hneg
hpos
recOn
sizeOf_spec
to_iff
noConfusion
right
eta
inj
binductionOn_2
term_∨_
liftCoeM
down_up
noConfusion
_sizeOf_1
_sizeOf_inst
sizeOf_spec
showTermElab
noConfusion
term_⊇_
noConfusionType
noConfusion
native
recOn
recOn
term_<<<_
const_apply
elim
lengthTRAux
match_1
lengthTR
nonemptyRight
succ_pos
checkTactic
boolIfThenElse
_sizeOf_1
_sizeOf_inst
sizeOf_spec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
instTransEq
rewriteSeq
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
recOn
instMonadQuotationOfMonadFunctorOfMonadLift
true_comp
not_false_iff
recOn
matchesIdent
noConfusion
val
noConfusion
precLead
recOn
instCoeTCOfCoe
recOn
sizeOf_spec
instTransIff
inductionOn₃
q₃
sizeOf_spec
recOn
traceState
noConfusion
kernel
instCoeT
rotateLeft
termMax_prec
eta
binductionOn
acNf0
ofBoolUsing_eq_false
toLawfulRightIdentity
instCoeOutTSyntaxSyntax
recOn
imp
injEq
injEq
sizeOf_spec
sizeOf_spec
tacIfThenElse
sizeOf
tacticInfer_instance
ind₂
applyAssumption
recOn
noConfusion
classical
instInhabitedMProd
stx_<|>_
noConfusion
imp_iff_not
recOn
recOn
term_*_
noConfusion
decide_true_eq_true
lt_of_eq_of_lt
instInhabitedForInStep
injection
recOn
hMod
sizeOf_spec
recOn
recOn
noConfusion
injEq
fst
prio(_)
noConfusion
clear
commandUnseal__
recOn
false_ne_true
inj
adapt
ρ'
instHashableSubtype
snd
case
recOn
nonemptyRight
instInhabitedParserDescr
recOn
snd
tacDepIfThenElse
recOn
recOn
term_∈_
by?
recOn
term_≤_
recOn
sizeOf_spec
foo
foo1
foo2
foo3
foo4
foo5
foo6
foo7
foo8
foo9
Foo
Foo1
Foo2
Foo3
Foo4
Foo5
Foo6
Foo7
Foo8
Foo9
nat_beq₁
nat_beq₂
nat_beq₃
nat_ble₂
nat_ble₁
nat_ble₃
FX
apply
eval
X
Y
decodeX
decodeY
PowerOfTwo
double
nat_mul₁
nat_mul₂
nat_mul₃
NX
leaf
branch
sizeNX
NY
sizeNY
nat_pow
lit_eq_lit
lit_eq_mk
nat_sub₁
nat_sub₂
nat_succ_eq_succ
UnitLike
ut
UX
nat_zero_eq_zero
inductivePredicate
Corpus
InductivePredicate
NestedInduction
rec_1
ibelow_1
below_1
binductionOn_1
brecOn_1
UniverseBumpingInduction
α_eq
β_eq
Inductive
FunctionalInduction