semiOutParam
u
α
MonadReaderOf
mk
v
a
_@
Init
Prelude
_hyg
read
m
ρ
read
self
Nat
zero
succ
n
LE
mk
le
le
le
refl
step
instLENat
OfNat
mk
ofNat
x
_@
Init
Prelude
_hyg
ofNat
instOfNatNat
rec
casesOn
t
succ
zero
motive
n_ih
rec
casesOn
step
refl
a_ih
_@
Init
Prelude
_hyg
Eq
refl
u_1
HEq
refl
β
rec
ndrec
u2
u1
h
b
rfl
symm
_@
Init
Prelude
_hyg
letFun
f
cast
rec
eq_of_heq
a'
this
h₁
noConfusionType
v1
P
n_eq
v2
noConfusion
h12
h1a
h11
pred_le_pred
match_1
_@
Init
Prelude
_hyg
h_3
h_2
h_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
outParam
EStateM
Backtrackable
mk
restore
save
σ
δ
rec
casesOn
mk
noConfusionType
restore_eq
save_eq
noConfusion
Subsingleton
rec
LT
mk
lt
lt
lt
instLTNat
Fin
mk
isLt
val
Iff
intro
Core
_hyg
mpr
mp
propext
propIntro
h₂
rec
casesOn
noConfusionType
val_eq
noConfusion
casesOn
injEq
_@
Init
Core
_hyg
Core
_hyg
HPow
mk
w
hPow
γ
hPow
Pow
mk
pow
pow
instHPow
u_2
inst
_@
Init
Prelude
_hyg
NatPow
mk
pow
instPowNat
PUnit
unit
PProd
mk
snd
fst
below
brecOn
F_1
Unit
unit
pow
match_1
mul
match_1
add
match_1
instNatPowNat
BitVec
ofFin
toFin
UInt32
ofBitVec
toBitVec
Or
inl
inr
And
intro
right
left
isValidChar
val
toFin
toNat
toBitVec
toNat
isValidChar
Char
mk
valid
rec
recOn
DoResultPRBC
rec
mp
rfl
ForInStep
done
yield
rec
casesOn
yield
done
noConfusionType
a_eq
_@
Init
Core
_hyg
noConfusion
inj
Core
_hyg
OrOp
mk
or
rec
casesOn
noConfusionType
or_eq
noConfusion
Inhabited
mk
default
default
instInhabitedForall
HMul
mk
hMul
rec
casesOn
noConfusionType
hMul_eq
Task
Priority
max
MonadExceptOf
mk
handler
body
tryCatch
throw
ε
Result
ok
error
throw
e
s
save
rec
casesOn
error
ok
tryCatch
match_1
restore
handle
d
instMonadExceptOfOfBacktrackable
_@
Init
Prelude
_hyg
HAndThen
mk
hAndThen
rec
casesOn
noConfusionType
hAndThen_eq
noConfusion
intro
allEq
False
Not
id
not_false
Functor
mk
mapConst
map
Pure
mk
pure
Seq
mk
seq
SeqLeft
mk
seqLeft
SeqRight
mk
seqRight
Applicative
mk
toSeqRight
toSeqLeft
toSeq
toPure
toFunctor
Bind
mk
bind
Monad
mk
toBind
toApplicative
ReaderT
map
toFunctor
toApplicative
mapConst
instFunctorOfMonad
r
_@
Init
Prelude
_hyg
pure
toPure
pure
seq
toSeq
seqLeft
toSeqLeft
seqRight
toSeqRight
instApplicativeOfMonad
Sum
inl
inr
rec
casesOn
inr
inl
noConfusionType
noConfusion
inj
Bool
false
true
rec
casesOn
true
false
ne_true_of_eq_false
match_1
EmptyCollection
mk
emptyCollection
Insert
mk
insert
Singleton
mk
singleton
insert
emptyCollection
singleton
LawfulSingleton
mk
insert_empty_eq
Core
_hyg
Decidable
isFalse
p
isTrue
rec
casesOn
isTrue
isFalse
if_neg
match_1
hc
c
Prod
mk
rec
casesOn
instSubsingletonProd
match_1
_@
Init
Core
_hyg
_@
Init
Core
_hyg
val
rec
absurd
casesOn
eq_of_val_eq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
val_ne_of_ne
h'
HasSubset
mk
Subset
rec
casesOn
List
nil
cons
tail
head
Array
mk
toList
Append
mk
append
HAppend
mk
hAppend
append
instHAppendOfAppend
elim
Membership
mk
mem
rec
casesOn
noConfusionType
mem_eq
MonadFunctor
rec
emptyRelation
Std
LeftIdentity
mk
o
op
Identity
mk
toLeftIdentity
rec
recOn
dite
instDecidableIff
_proof_5
hq
hp
q
_proof_6
mpr
_proof_7
_proof_8
rec
Complement
mk
complement
rec
recOn
Function
comp
g
const
const_comp
u_3
rec
recOn
rec
recOn
unit
pure
get
rec
casesOn
noConfusionType
Thunk
mk
fn
_private
Init
Core
Thunk
fn
get
Ne
DoResultPR
pure
return
rec
casesOn
return
noConfusionType
noConfusion
rec
casesOn
intro
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
trans
Mod
mk
mod
HMod
mk
hMod
mod
instHMod
MonadState
mk
modifyGet
set
rec
recOn
insert_empty_eq
insert_emptyc_eq
rec
recOn
Max
mk
max
rec
casesOn
noConfusionType
optParam
rec
below
tail_ih
brecOn
casesOn
cons
nil
length
match_1
as
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
HAdd
mk
hAdd
hAdd
Add
mk
add
add
instHAdd
instAddNat
toList
size
pred
_
sub
Min
mk
min
min
DecidableRel
ite
minOfLe
y
beq
match_1
h_4
ble
DecidableEq
decEq
match_1
_@
Init
Prelude
_hyg
noConfusionType
noConfusion
instDecidableEqBool
le_of_ble_eq_true
match_1
zero_le
match_1
below
refl
_@
Init
Prelude
_hyg
step
brecOn
ih
_@
Init
Prelude
_hyg
rec
casesOn
succ_le_succ
match_1
_@
Init
Prelude
_hyg
h_below
_@
Init
Prelude
_hyg
funType
ble_eq_true_of_le
match_1
_@
Init
Prelude
_hyg
ble_self_eq_true
match_1
ble_succ_eq_true
match_1
not_le_of_not_ble_eq_true
decLe
instMinNat
decLt
appendCore
loop
match_1
concat
match_1
push
elim
C
get
match_1
_@
Init
Prelude
_hyg
i
le_trans
match_1
_@
Init
Prelude
_hyg
k
_@
Init
Prelude
_hyg
le_succ
le_of_succ_le_succ
_proof_34
getInternal
extract
loop
bs
j
_@
Init
Prelude
_hyg
i'
hlt
emptyWithCapacity
stop
start
sz'
BEq
mk
beq
beq
ReflBEq
mk
LawfulBEq
mk
eq_of_beq
toReflBEq
decide
instBEqOfDecidableEq
of_decide_eq_self_eq_true
match_1
of_decide_eq_true
match_1
decide_eq_false
match_1
instLawfulBEq
Core
_hyg
ShiftLeft
mk
shiftLeft
rec
recOn
rec
casesOn
noConfusionType
fn_eq
noConfusion
String
Pos
mk
byteIdx
rec
casesOn
noConfusionType
noConfusion
inj
byteIdx_eq
_@
Init
Core
_hyg
term_⊂_
Lean
TrailingParserDescr
ParserDescr
trailingNode
Name
mkStr1
binary
symbol
cat
IdempotentOp
mk
idempotent
rec
casesOn
noConfusionType
noConfusion
HShiftLeft
mk
hShiftLeft
rec
casesOn
noConfusionType
_sizeOf_1
SizeOf
sizeOf
_sizeOf_inst
mk
sizeOf_spec
rec
ndrec
rec
casesOn
elim
match_1
Sub
mk
sub
rec
recOn
DoResultBC
break
continue
rec
casesOn
continue
break
noConfusionType
noConfusion
injEq
modifyGet
modify
NonScalar
rec
Neg
mk
neg
rec
casesOn
noConfusionType
neg_eq
instDecidableAnd
match_1
dq
_@
Init
Prelude
_hyg
right
_proof_2
left
_proof_3
dp
_@
Init
Prelude
_hyg
UInt64
size
decidable_of_decidable_of_iff
_proof_2
rec
casesOn
noConfusionType
noConfusion
hMod_eq
recOn
ofNatLT
rec
casesOn
noConfusionType
toSeqRight_eq
toSeqLeft_eq
toSeq_eq
toPure_eq
toFunctor_eq
Associative
rec
term_⊃_
HDiv
mk
hDiv
rec
recOn
Equivalence
mk
z
trans
symm
Setoid
mk
iseqv
HasEquiv
mk
Equiv
Equiv
r
instHasEquivOfSetoid
Quot
Quotient
lift
lift
refl
iseqv
refl
lift₂
_proof_29
b₂
a₂
b₁
a₁
s₂
s₁
φ
mk
mk
ind
ind
_proof_30
q₂
uA
uB
uC
q₁
mk
data
Substring
mk
stopPos
startPos
str
rec
recOn
startPos
rec
casesOn
rfl
rfl
refl
Mul
mk
mul
rec
casesOn
noConfusionType
Div
mk
div
rec
recOn
pure
return
break
continue
casesOn
noConfusionType
noConfusion
imp_intro
casesOn
noConfusionType
pow_eq
PSum
inl
inr
rec
casesOn
noConfusionType
congr
f₂
f₁
dcond
match_1
_@
Init
Prelude
_hyg
rec
casesOn
rec
casesOn
noConfusionType
r_eq
noConfusion
inline
eq_1
rec
casesOn
noConfusionType
Equiv_eq
lt_of_le_of_lt
intro_left
noConfusionType
tail_eq
head_eq
noConfusion
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
ndrecOn
subst
byteIdx
instHAddPos
p₂
p₁
byCases
match_1
h2
h1
dec
_@
Init
Core
_hyg
em
RightIdentity
rec
instDecidableEqSum
match_1
Core
_hyg
casesOn
noConfusionType
insert_eq
noConfusion
rec
rec
casesOn
noConfusionType
rec
casesOn
noConfusionType
noConfusion
comp_def
instSubsingletonDecidable
match_1
instLEBitVec
x2
_@
Init
Prelude
_hyg
x1
_@
Init
Prelude
_hyg
instLEUInt32
size
ofNatLT
utf8Size
_proof_25
inferInstanceAs
instDecidableLeBitVec
decLe
instDecidableLeUInt32
_proof_26
_proof_27
Zero
mk
rec
casesOn
noConfusionType
noConfusion
noConfusion
term_∪_
SDiff
mk
sdiff
MonadWithReaderOf
mk
withReader
rec
casesOn
noConfusionType
withReader_eq
noConfusion
if_pos
match_1
symm
symm
hab
noConfusionType
snd_eq
fst_eq
noConfusion
instLEPos
instDecidableLePos
readThe
rec
casesOn
noConfusionType
noConfusion
UInt16
ofBitVec
rec
casesOn
ofBitVec
noConfusionType
toBitVec_eq
noConfusion
MonadReader
rec
rec
casesOn
noConfusionType
rec
Subtype
rec
recOn
Nonempty
intro
rec
casesOn
elim
match_1
_@
Init
Prelude
_hyg
instNonemptyPProd
le_antisymm
match_1
not_succ_le_self
match_1
not_succ_le_zero
match_3
match_1
match_2
lt_irrefl
HasSSubset
mk
SSubset
rec
casesOn
noConfusionType
SSubset_eq
noConfusion
rec
casesOn
noConfusionType
noConfusion
rec
recOn
Relation
TransGen
single
tail
flip
imp
swap
imp_not_comm
intro
recOn
_sizeOf_1
instSizeOfForallUnit
_sizeOf_inst
sizeOf_spec
mk
property
System
Platform
getNumBits
_proof_5
GE
ge
lt_or_ge
match_2
HAnd
mk
hAnd
rec
casesOn
noConfusionType
noConfusion
USize
size_pos
match_1
ShiftRight
mk
shiftRight
rec
casesOn
noConfusionType
Except
error
ok
rec
casesOn
UInt8
ofBitVec
rec
casesOn
noConfusionType
noConfusion
injEq
_@
Init
Core
_hyg
rec
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
LawfulLeftIdentity
mk
left_id
val
numBits
ofBitVec
rec
casesOn
decEq
match_1
_@
Init
Prelude
_hyg
toBitVec
casesOn
noConfusionType
noConfusion
ForIn
mk
u₁
u₂
xs
forIn
Commutative
rec
OrElse
mk
orElse
MonadStateOf
mk
casesOn
noConfusionType
toList_eq
noConfusion
injEq
_@
Init
Core
_hyg
mk
assoc
casesOn
noConfusionType
comp_const
map
Pi
instInhabited
rec
casesOn
noConfusionType
seqLeft_eq
noConfusion
liftOn
congrArg
sound
funext
extfunApp
eqv
inj
mkArray2
True
intro
trivial
of_iff_true
rec
casesOn
noConfusionType
PSigma
mk
rec
casesOn
Exists
of_psigma_prop
match_1
hx
toBoolUsing
decide_eq_true
match_1
toBoolUsing_eq_true
imp_congr_left
mt
ha
refl
rfl
of_eq
neq_of_not_iff
mkArray5
a₅
a₄
a₃
irrefl
term∅
node
sizeOf_spec
instDecidableEqChar
match_1
decEq
decEq
match_1
rec
casesOn
ofFin
decEq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
instDecidableEqFin
match_1
decEq
match_1
eq_of_beq_eq_true
match_1
ne_of_beq_eq_false
match_1
instDecidableEqNat
eq_of_val_eq
match_1
val_eq_of_eq
_proof_6
_proof_7
noConfusionType
toFin_eq
noConfusion
_proof_8
instDecidableEqBitVec
_proof_15
noConfusion
_proof_16
instDecidableEqUInt32
val_eq_of_eq
match_1
ne_of_val_ne
inferInstance
instLawfulBEqChar
of_toBoolUsing_eq_true
ofBoolUsing_eq_true
id_eq
Xor
mk
xor
rec
casesOn
inhabitedLeft
instInhabited
eqRec_heq
match_1
_@
Init
Core
_hyg
One
mk
one
rec
recOn
inj
instBEq
instReflBEq
instDecidableEqPos
match_2
symm
comm
or_comm
trans
subst
heq_of_eq
heq_of_eq_of_heq
ndrecOn
fst
indep
eta
indepCoherent
liftIndepPr1
snd
rec
allEq
elim
recOnSubsingleton
_proof_27
_@
Init
Core
_hyg
recOnSubsingleton
Empty
rec
mem
ForIn'
mk
forIn'
rec
recOn
AndOp
mk
and
rec
casesOn
noConfusionType
noConfusion
PEmpty
MonadLiftT
mk
monadLift
rec
casesOn
noConfusionType
monadLift_eq
noConfusion
rec
elim
H1
H2
iff_of_false
hb
iff_false_left
Total
mk
total
total
decide_false
match_1
decide_false_eq_false
sound
ofBitVec
rec
recOn
noConfusion
inj
MonadEvalT
mk
monadEval
rec
casesOn
noConfusionType
noConfusion
cast_heq
match_1
Core
_hyg
ULift
rec
mk
comm
mk
LawfulRightIdentity
mk
right_id
toRightIdentity
LawfulIdentity
mk
toLawfulRightIdentity
toLawfulLeftIdentity
toIdentity
LawfulCommIdentity
mk
toLawfulIdentity
HomogeneousPow
mk
pow
term_∩_
byContradiction
np
noConfusionTypeEnum
intro
MProd
mk
instNonemptyMProd
fst
snd
lexLt
rec
DoResultSBC
pureReturn
break
continue
rec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
inductionOn₂
casesOn
noConfusionType
pure_eq
noConfusion
shiftLeft
instHShiftLeftOfShiftLeft
Union
mk
union
union
throw
throwThe
inj
inductionOn
exists_rep
thunkCoe
CoeTail
mk
MonadExcept
ofExcept
match_1
noConfusionType
casesOn
subsingleton
_@
Init
Core
_hyg
PNonScalar
mk
rec
casesOn
noConfusionType
intro
inj
_@
Init
Core
_hyg
_@
Init
Core
_hyg
inj
_@
Init
Core
_hyg
comm
mk
casesOn
noConfusionType
noConfusion
monadEval
AndThen
mk
andThen
andThen
instHAndThenOfAndThen
HOrElse
mk
hOrElse
rec
casesOn
noConfusionType
Hashable
mk
hash
ofNatLT
instInhabitedUInt64
_proof_20
hash
instHashableString
injEq
rec
casesOn
noConfusionType
HXor
mk
hXor
hXor
hAndThen
mk'
term_↔_
noConfusionType
size
size_eq
match_1
property
numBits_eq
ne_false_of_eq_true
match_1
instDecidableForall
_proof_4
instInhabitedSubstring
rec
casesOn
decEq
match_1
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
_@
Init
Prelude
_hyg
hasDecEq
match_3
_proof_28
_proof_29
_proof_30
match_2
nab
match_1
habs
nabs
_proof_31
_proof_32
_proof_33
instDecidableEqList
_proof_35
noConfusionType
data_eq
noConfusion
_proof_36
instDecidableEqString
rec
utf8ByteSize
match_1
go
match_1
cs
instHAddPosString
casesOn
rec
recOn
Irrefl
mk
irrefl
rec
casesOn
HOr
rec
mul
sub
rec
casesOn
noConfusionType
toBind_eq
toApplicative_eq
noConfusion
decEq
match_1
_proof_12
_proof_13
bind
match_1
instDecidableEqOfLawfulBEq
match_1
trans
not_eq_of_beq_eq_false
toReflBEq
_proof_1
eq_of_beq
Option
none
some
rec
casesOn
some
none
noConfusionType
noConfusion
inj
recOn
heq_of_eqRec_eq
casesOn
noConfusionType
noConfusion
inj
recOn
elim
Subrelation
Asymm
mk
asymm
instMinPos
noConfusion
instHAddPosChar
mk
rec
casesOn
panicCore
msg
panic
instDecidableFalse
dummyRestore
isLt
rec
recOn
decidable_of_decidable_of_eq
_proof_3
inj
trans
trans
hbc
rec
casesOn
noConfusionType
ofNatLT
casesOn
noConfusionType
rec
recOn
iff_false_intro
not_not_intro
hn
not_iff_false_intro
ne_self_iff_false
rec
casesOn
noConfusionType
modifyGet_eq
set_eq
get_eq
instDecidableEqProd
match_2
map
v₁
v₂
β₂
β₁
α₂
α₁
map_apply
u_4
rec
mixHash
not_congr
rec
casesOn
recOn
iff_of_true
iff_true_intro
imp_true_iff
dif_eq_if
match_1
recOn
Squash
mk
ind
instSubsingletonSquash
MonadLift
mk
monadLift
liftM
monadLift
instMonadLiftTOfMonadLift
instMonadLiftT
mk
read
instMonadReaderOfMonadReaderOf
instMonadReaderOfOfMonadLift
rec
casesOn
instInhabitedPProd
instDecidableEqUInt16
inhabitedRight
recOn
exists_of_subtype
match_1
inj
casesOn
noConfusionType
read_eq
noConfusion
rec
casesOn
single
Core
_hyg
noConfusion
recOn
get
MonadWithReader
mk
rec
casesOn
noConfusionType
noConfusion
recOn
recOn
casesOn
recOn
hDiv
rec
recOn
instPowOfHomogeneousPow
symm
comm
casesOn
bsize
match_1
Sep
mk
sep
rec
casesOn
noConfusionType
sep_eq
rec
Trans
mk
not_not_not
recOn
rec
casesOn
noConfusionType
casesOn
elim
match_1
instSubsingletonPEmpty
sizeOf_spec
noConfusionType
noConfusion
inj
indBeta
recOn
casesOn
recOn
eq_true_of_ne_false
match_1
injEq
casesOn
pureReturn
noConfusionType
noConfusion
cond
match_1
not
symm
match_1
comm
and_comm
casesOn
noConfusionType
rec
noConfusionType
rec
casesOn
Classical
choice
ofNonempty
_proof_1
instNonemptyTask
Core
_hyg
default
get
map
sync
prio
le_of_le_of_eq
instDecidableOr
match_1
_proof_4
lexLtDec
mkArray3
dif_neg
match_1
hnc
ibelow
noConfusionType
mapConst_eq
map_eq
noConfusion
rec
casesOn
rec
Sigma
mk
rec
casesOn
noConfusionType
noConfusion
inj
Prelude
Init
Core
_hyg
inj
_@
Init
Core
_hyg
rec
casesOn
elim
match_1
Core
_hyg
match_1
size
casesOn
recOn
recOn
instDecidableTrue
le_of_lt_succ
casesOn
noConfusionType
noConfusion
rec
casesOn
noConfusionType
tryCatch_eq
throw_eq
noConfusion
set
match_1
casesOn
noConfusion
inj
injEq
recOn
instInhabitedSort
mk
monadMap
casesOn
noConfusionType
monadMap_eq
rec
casesOn
noConfusionType
noConfusion
injEq
noConfusion
injEq
_sizeOf_1
_sizeOf_inst
sizeOf_spec
inj
casesOn
casesOn
noConfusionType
bind_eq
HSub
mk
hSub
instHSub
recOn
liftBeta
up
down
casesOn
up
noConfusionType
down_eq
noConfusion
mkArray1
noConfusionType
_hyg
noConfusion
injEq
Init
Core
_hyg
Init
Core
_hyg
noConfusionType
stopPos_eq
startPos_eq
str_eq
noConfusion
zero
MonadEval
mk
monadEval
instMonadEvalTOfMonadEval
NonemptyType
instInhabitedNonemptyType
inj
rec
recOn
hMul
inj
rec
casesOn
type
type
recOn
recOn
hrecOn
_proof_28
hrecOn
casesOn
noConfusionType
rec
recOn
exists_rep
noConfusionType
mk
hOr
casesOn
noConfusionType
noConfusion
injEq
of_decide_eq_false
match_1
rec
recOn
casesOn
MonadFunctorT
mk
monadMap
casesOn
noConfusionType
noConfusion
inhabitedRight
injEq
recOn
recOn
spawn
injEq
_@
Init
Core
_hyg
_@
Init
Core
_hyg
_@
Init
Core
_hyg
recOn
lt_of_lt_of_eq
instInhabitedBool
rec
casesOn
decide_true
match_1
heq_self_iff_true
below
rec
PLift
up
rec
casesOn
instMonadEvalT
proof_irrel
instSubsingleton
recOnSubsingleton₂
_proof_32
t₁
t₂
decidableEq
_proof_33
match_1
liftOn₂
Quotient
rel
_proof_31
a₂b₂
a₁b₁
a₁a₂
b₁b₂
inductionOn
refl
rel_of_eq
exact
_proof_34
type_eq_of_heq
inj
eq_or_lt_of_le
match_2
recOn
symm
comm
iff_false_right
injEq
maxOfLe
instMaxUInt32
noConfusionType
default_eq
noConfusion
snd
modifyGet
modifyGetThe
rec
noConfusion
not_and_iff_or_not
match_2
casesOn
recOn
iff_not_self
H
inj
noConfusionType
modifyThe
casesOn
noConfusionType
casesOn
noConfusionType
noConfusion
Refl
mk
rec
recOn
casesOn
down
term_⊕'_
run
injEq
casesOn
noConfusionType
get
set
getThe
instMonadStateOfMonadStateOf
instMonadStateOfOfMonadLift
imp_congr_right
hcd
imp_congr_ctx
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
casesOn
noConfusionType
instNonemptyOfMonad
match_1
liftOn
neg_resolve_left
noConfusion
DecidableLT
toRightIdentity
noConfusionType
complement
noConfusion
instLTBitVec
imp_imp_imp
h₀
recOn
noConfusionType
noConfusion
recOn
beq_of_eq
match_1
beq_iff_eq
instMonadLift
throw
tryCatch
tryCatchThe
instMonadExceptOfMonadExceptOf
instMonadExceptOf
recOn
recOn
not_true
ne_of_beq_false
noConfusion
injEq
recOn
false_iff_true
withReader
xor
max
instDecidableEq
match_1
cast_eq
recOn
down
eq_self_iff_true
inj
rec
HShiftRight
mk
hShiftRight
hShiftRight
Inter
mk
inter
inter
rec
recOn
Dvd
mk
dvd
ge_iff_le
sizeOf_spec
of_toBoolUsing_eq_false
add_zero
size
noConfusion
instMulNat
single
Core
_hyg
tail
casesOn
injEq
withReader
withTheReader
instMonadWithReaderOfMonadWithReaderOf
recOn
noConfusion
instInhabitedList
heq_comm
casesOn
noConfusionType
rec
noConfusionType
noConfusion
noConfusion
zero_lt_succ
injEq
noConfusionType
noConfusion
iff_comm
instCommutativeIff
getModify
casesOn
instMonadFunctor
ctx
eq
match_1
_@
Init
Core
_hyg
get
set
modifyGet
match_1
Prelude
_hyg
instMonadStateOf
down_up
false_imp_iff
noConfusionEnum
_proof_9
casesOn
noConfusionType
sizeOf_spec
injEq
noConfusionType
recOn
SSubset
SSuperset
recOn
insert_emptyc_eq
monadMap
instMonadFunctorTOfMonadFunctor
monadFunctorRefl
instMonadWithReaderOfOfMonadFunctor
rec
casesOn
recOn
_sizeOf_1
_sizeOf_inst
sizeOf_spec
instHMul
sep
casesOn
noConfusionType
a2
a1
instLawfulBEq
recOn
recOn
rec
toIdentity
endPos
toSubstring
recOn
heq_of_heq_of_eq
b'
id_def
term_⊕_
recOn
iff_true_left
casesOn
noConfusionType
noConfusion
rec
recOn
recOn
existsOfSubtype
iff_of_eq
recOn
helim
data
decEq
match_1
_proof_9
_proof_10
instDecidableEqUInt8
rec
instSubsingleton
_proof_37
_proof_38
he
match_1
noConfusion
Antisymm
mk
antisymm
rec
casesOn
recOn
casesOn
noConfusionType
seqRight_eq
mkArray0
set
rec
recOn
noConfusionType
noConfusion
le_of_eq_of_le
dedicated
injEq
noConfusion
inj
injEq
_@
Init
Core
_hyg
noConfusion
noConfusion
_sizeOf_1
_sizeOf_inst
sizeOf_spec
injEq
rec
recOn
imp_false
recOn
decEq
match_1
_proof_18
noConfusionType
noConfusion
_proof_19
neg
inj
valid
getD
match_1
opt
_@
Init
Prelude
_hyg
map
instInhabitedNat
match_3
instMonadWithReaderOfReaderT
_sizeOf_1
_sizeOf_inst
sizeOf_spec
recOn
map_snd
false_of_ne
recOn
resolve_left
na
iff_iff_eq
instDecidableNot
toLeftIdentity
substr
toBitVec
noConfusion
noConfusionType
noConfusion
inj
noConfusionType
noConfusion
instInhabitedUSize
antisymm
inj
and
match_1
strictAnd
rec
casesOn
foldl
match_1
l
init
ne_true_of_not
hnp
recOn
rec
casesOn
noConfusionType
recOn
injEq
eq_false_of_ne_true
match_1
recOn
injEq
noConfusionType
sizeOf_spec
noConfusion
noConfusion
casesOn
noConfusionType
noConfusion
instInhabitedForInStep_1
dvd
recOn
casesOn
div
instHDiv
symm
ne_comm
instDecidableEqOfIff
match_1
_@
Init
Core
_hyg
_proof_21
heq
orElse
x₂
x₁
injEq
recOn
bind
toBind
bind
instMonad
stopPos
recOn
casesOn
casesOn
noConfusionType
beq_eq
noConfusion
injEq
Subset
Superset
noConfusion
inj
casesOn
noConfusionType
casesOn
noConfusionType
noConfusion
instDecidableIte
dE
dT
dC
_@
Init
Core
_hyg
instSubNat
casesOn
noConfusionType
dvd_eq
recOn
recOn
and
instHAndOfAndOp
noConfusionType
_@
Init
Prelude
_hyg
InvImage
instOrElseOfBacktrackable
casesOn
noConfusionType
not_of_iff_false
injEq
instLawfulBEqString
map
pure
seqRight
instMonad
inj
recOn
toLawfulLeftIdentity
recOn
sizeOf_spec
optParam_eq
_proof_10
_proof_11
injEq
Init
Core
_hyg
Init
Core
_hyg
elim
instSubsingletonEmpty
casesOn
recOn
elim
recOn
injEq
rec
recOn
hAppend
recOn
match_1
instNonempty
instCommutativeOr
true_eq_false_of_false
instInhabitedPos
bind
recOn
casesOn
noConfusionType
noConfusion
rec
casesOn
noConfusionType
andThen_eq
dif_pos
match_1
iff_iff_implies_and_implies
iff_def
iff_def'
_proof_21
noConfusion
_proof_22
_sizeOf_1
_sizeOf_inst
sizeOf_spec
casesOn
ibelow
inj
nonemptyLeft
injEq
recOn
left_id
noConfusion
instDecidableLtBitVec
GT
gt
hAnd
false_comp
injEq
asymm
ofNatLT
instTransEq_1
noConfusion
match_3
shiftRight
noConfusion
lift
_proof_35
recOn
rec
casesOn
casesOn
casesOn
instLTPos
instDecidableLtPos
instLEFin
nonempty_of_exists
match_1
noConfusionType
seq_eq
adaptExcept
match_1
bind
instInhabitedPNonScalar
injEq
noConfusion
forIn
imp_congr
hOr
inj
noConfusionType
noConfusion
recOn
Antisymm
instInhabitedNonScalar
toRightIdentity
instBEqProd
mkArray4
str
toArray
injEq
subst
injEq
recOn
match_1
d₂
_@
Init
Core
_hyg
d₁
_@
Init
Core
_hyg
casesOn
noConfusionType
mpr
or
instHOrOfOrOp
inj
orElse
instHOrElseOfOrElse
recOn
recOn
instDecidableEqPUnit
noConfusion
complement_eq
rec
casesOn
noConfusionType
noConfusion
inj
recOn
congrFun
toSubstring'
mkEmpty
inj
noConfusionType
trans_eq
noConfusion
instInhabitedUInt16
_proof_14
rec
casesOn
noConfusionType
noConfusionType
noConfusion
instMinUInt32
noConfusionType
comm
recOn
instInhabitedOption
bne
inj
inj
instInhabitedTask
noConfusion
noConfusion
recOn
noConfusionType
recOn
toLawfulIdentity
recOn
recOn
recOn
toLeftIdentity
right_id
sizeOf_eq
_@
Init
Core
_hyg
term{}
noConfusion
injEq
inj
tryCatch
orElse
noConfusion
noConfusion
recOn
hSub
instMaxPos
inj
term_<->_
idempotent
instNonemptyOfInhabited
instDecidableEqPEmpty
mp
instInhabitedExcept
instHSubPos
recOn
inhabitedLeft
noConfusionType
noConfusion
injEq
_@
Init
Core
_hyg
term_≈_
_proof_18
e₂
e₁
_proof_19
n₂
e₂'
_proof_20
n₁
e₁'
map_fst
casesOn
noConfusionType
injEq
recOn
instLTUInt32
decLt
instDecidableLtUInt32
casesOn
noConfusionType
recOn
recOn
irrefl
instLawfulBEqBool
ofNatLT
instInhabitedUInt8
_proof_11
run
one
binductionOn
hShiftLeft
instInhabitedPUnit
instNonemptyForall
noConfusion
casesOn
noConfusionType
noConfusion
recOn
recOn
inj
instSubsingletonPUnit
intro_right
injEq
term_!=_
recOn
noConfusion
instInhabitedTrue
instInhabitedForallOfMonad
ε'
inj
recOn
injEq
recOn
recOn
neg_resolve_right
nb
recOn
le_succ_of_le
match_1
le_refl
or
strictOr
fst
noConfusionType
noConfusion
Prelude
isValidChar_UInt32
match_1
Prelude
_hyg
Prelude
_hyg
le_step
lt_trans
ofNatAux
ofNat
_proof_23
_proof_24
instInhabitedReaderT
term_\_
noConfusion
iff_true_right
recOn
instMonadEvalOfMonadLift
recOn
not_not_of_not_imp
comp_apply
instNonemptyProd
noConfusion
sizeOf_spec
imp_not_self
noConfusionType
hash_eq
noConfusion
noConfusionType
forIn_eq
noConfusion
noConfusionType
imp_iff_right
true_imp_iff
_sizeOf_1
_sizeOf_inst
sizeOf_spec
fst
noConfusion
rec
noConfusion
lt_of_le_of_ne
match_1
h₃
inj
noConfusion
instDecidableDite
recSubsingleton
h₄
instInhabitedProp
injEq
recOn
recOn
term_⊆_
up_down
trans
Core
_hyg
noConfusionType
noConfusion
nonemptyLeft
casesOn
noConfusionType
forIn'_eq
recOn
forIn'
instHXorOfXor
eq_comm
recOn
eq_punit
refl
recOn
instHShiftRightOfShiftRight
hash
noConfusionType
toBitVec
inj
_proof_12
_proof_13
_proof_14
_proof_15
_proof_16
_proof_17
not_lt_zero
recOn
noConfusionType
injEq
noConfusionType
noConfusion
not_of_not_imp
sdiff
term_≠_
recOn
trans
injEq
noConfusion
of_not_not
hnn
injEq
instLTFin
decLt
ne_false_of_self
recOn
inj
DecidablePred
e_snd
e_fst
noConfusion
recOn
DecidableLE
recOn
recOn
recOn
true_iff_false
inj
dflt
read
instMonadReaderOfReaderTOfMonad
resolve_right
recOn
recOn
mkArray7
a₇
a₆
getD
v₀
imp_self
eq_iff_true_of_subsingleton
decLe
noConfusionType
noConfusion
sizeOf_spec
of_not_eq_false
match_1
true_ne_false
lexLt_def
instCommutativeAnd
pure
instDecidableEqEmpty
get!Internal
recOn
assoc
up_down
noConfusion
inj
noConfusion
of_not_eq_true
match_1
beq_false_of_ne
_a
noConfusion
false_of_true_iff_false
instOrElse
instInhabitedProd
noConfusion
recOn
hOrElse
eq_iff_iff
false_of_true_eq_false
noConfusion
recOn
run'
noConfusionType
singleton_eq
noConfusion
inj
instInhabitedResult
instDecidableEqUSize
instInhabitedUInt32
_proof_17
gt_iff_lt
instDecidableEqUInt64
injEq
noConfusion
noConfusion
recOn
toBitVec
instInhabitedOfMonad
noConfusion
iteInduction
hneg
hpos
recOn
to_iff
eta
inj
mkArray6
down_up
noConfusion
mkArray8
a₈
noConfusion
term_⊇_
recOn
recOn
const_apply
elim
lengthTRAux
match_1
lengthTR
nonemptyRight
succ_pos
_sizeOf_1
instSizeOfNat
_sizeOf_inst
sizeOf_spec
_sizeOf_1
_sizeOf_inst
sizeOf_spec
instTransEq
recOn
true_comp
not_false_iff
recOn
noConfusion
val
noConfusion
recOn
recOn
instTransIff
inductionOn₃
q₃
s₃
sizeOf_spec
recOn
noConfusion
eta
binductionOn
dummySave
ofBoolUsing_eq_false
toLawfulRightIdentity
recOn
imp
injEq
injEq
ind₂
noConfusion
instInhabitedMProd
noConfusion
imp_iff_not
recOn
noConfusion
decide_true_eq_true
lt_of_eq_of_lt
instInhabitedForInStep
namedPattern
recOn
hMod
sizeOf_spec
recOn
recOn
noConfusion
fst
noConfusion
empty
recOn
false_ne_true
inj
adapt
ρ'
instHashableSubtype
snd
recOn
nonemptyRight
recOn
snd
recOn
nonBacktrackable
recOn
recOn
foo
foo1
foo2
foo3
foo4
foo5
foo6
foo7
foo8
foo9
Foo
Foo1
Foo2
Foo3
Foo4
Foo5
Foo6
Foo7
Foo8
Foo9
nat_beq₁
nat_beq₂
nat_beq₃
nat_ble₂
nat_ble₁
nat_ble₃
FX
const
apply
eval
X
Y
decodeX
decodeY
PowerOfTwo
double
nat_mul₁
nat_mul₂
nat_mul₃
NX
leaf
branch
sizeNX
NY
sizeNY
nat_pow
lit_eq_lit
lit_eq_mk
nat_sub₁
nat_sub₂
nat_succ_eq_succ
UnitLike
ut
UX
nat_zero_eq_zero
inductivePredicate
Corpus
InductivePredicate
NestedInduction
motive_1
rec_1
motive_2
ibelow_1
below_1
F_2
binductionOn_1
brecOn_1
UniverseBumpingInduction
α_eq
β_eq
Inductive
FunctionalInduction